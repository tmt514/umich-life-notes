# C++與程式邏輯訓練 (1)

<!-- toc -->

## 7. 搜索方法

遞迴在這裡的應用就是，只要著重當前就可以了，不用顧慮全局。

### 7.1 樹序走訪

讓我們來考慮一棵二元樹(Binary Tree)，即每一個節點有「左子樹」和「右子樹」（子樹可以為空）。

![](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/pix/tree1.bmp)

(Figure from CMU.)


#### 前序走訪 (pre-order traversal)

基本上就是對於每一個節點的遞迴走訪，通常以「中－左－右」的順序進行造訪。

例如上面的例子來說，前序走訪為：8, 5, 9, 7, 1, 12, 2, 4, 11, 3

#### 中序走訪 (in-order traversal)

基本上就是對於每一個節點的遞迴走訪，通常以「左－中－右」的順序進行造訪。

以上面的例子來說，中序走訪為：9, 5, 1, 7, 2, 12, 8, 4, 3, 11

#### 後序走訪 (post-order traversal)

基本上就是對於每一個節點的遞迴走訪，通常以「左－右－中」的順序進行造訪。

#### 前序中序轉後序

請想一個演算法，給你前序、中序表達式，可以輸出後序走訪。（或者是建立整棵樹）

#### 延伸思考

給定一棵二元樹的前序、中序表達式，可以唯一確定一棵樹的長相。那麼如果我們給定前序、後序表達式，這棵樹的中序走訪可能有幾種呢？

#### 算式剖析 - 波蘭表達式 (Polish expression)

我們在計算四則運算的時候，往往因為優先權導致電腦判斷相當困難。若我們使用這個算式的「後序」表達式，
就可以很輕鬆地計算了！

### 7.2 產生所有排列

### 7.3 深度優先搜索 (Depth First Search)
